<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ugly Runner Game w/ Coin Assets</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      text-align: center;
      margin: 0;
      padding-top: 20px;
    }
    canvas {
      border: 2px solid #444;
      background: #222;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>

<h1>Ugly Runner</h1>
<p>Press Space or Click to Jump â€” Collect Coins!</p>

<canvas id="gameCanvas" width="800" height="400"></canvas>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const GAME_WIDTH = canvas.width;
  const GAME_HEIGHT = canvas.height;

  const GROUND_HEIGHT = 60;
  const GROUND_Y = GAME_HEIGHT - GROUND_HEIGHT;

  const player = {
    x: 80,
    y: GROUND_Y - 40,
    width: 40,
    height: 40,
    vy: 0,
    jumpStrength: 18,
    onGround: true
  };

  const GRAVITY = 60;

  // Load 5 coin images & values
  const coinImages = [];
  const coinValues = [1, 2, 3, 4, 5];

  for (let i = 1; i <= 5; i++) {
    const img = new Image();
    img.src = `assets/coin${i}.png`;
    coinImages.push(img);
  }

  let obstacles = [];
  let coins = [];
  let obstacleTimer = 0;
  let obstacleInterval = 1.2;

  let coinTimer = 0;
  let coinInterval = 0.9;

  let lastTime = 0;
  let score = 0;
  let coinsCollected = 0;
  let gameState = "playing";
  let speedMultiplier = 1;

  function resetGame() {
    obstacles = [];
    coins = [];
    score = 0;
    coinsCollected = 0;
    speedMultiplier = 1;

    player.y = GROUND_Y - player.height;
    player.vy = 0;
    player.onGround = true;
    gameState = "playing";
  }

  function spawnObstacle() {
    const width = 30 + Math.random() * 40;
    const height = 30 + Math.random() * 50;

    obstacles.push({
      x: GAME_WIDTH + 20,
      y: GROUND_Y - height,
      width,
      height,
      speed: 280 + Math.random() * 80
    });
  }

  function spawnCoin() {
    // Pick a random coin image and value
    const index = Math.floor(Math.random() * 5);

    const img = coinImages[index];
    const value = coinValues[index];

    const size = 32;
    const y = GROUND_Y - 40 - Math.random() * 100;

    coins.push({
      x: GAME_WIDTH + 40,
      y,
      size,
      img,
      value,
      speed: 280
    });
  }

  function handleJumpOrRestart() {
    if (gameState === "gameOver") {
      resetGame();
      return;
    }
    if (player.onGround) {
      player.vy = -player.jumpStrength;
      player.onGround = false;
    }
  }

  document.addEventListener("keydown", e => {
    if (e.code === "Space") {
      e.preventDefault();
      handleJumpOrRestart();
    }
  });

  canvas.addEventListener("mousedown", handleJumpOrRestart);
  canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    handleJumpOrRestart();
  }, { passive: false });

  function update(dt) {
    if (gameState !== "playing") return;

    speedMultiplier += dt * 0.03;

    player.vy += GRAVITY * dt;
    player.y += player.vy;

    if (player.y + player.height >= GROUND_Y) {
      player.y = GROUND_Y - player.height;
      player.vy = 0;
      player.onGround = true;
    }

    obstacleTimer += dt;
    if (obstacleTimer >= obstacleInterval / speedMultiplier) {
      spawnObstacle();
      obstacleTimer = 0;
    }

    coinTimer += dt;
    if (coinTimer >= coinInterval / speedMultiplier) {
      if (Math.random() < 0.65) spawnCoin();
      coinTimer = 0;
    }

    obstacles.forEach(o => {
      o.x -= o.speed * dt * speedMultiplier;
    });

    coins.forEach(c => {
      c.x -= c.speed * dt * speedMultiplier;
    });

    obstacles = obstacles.filter(o => o.x + o.width > 0);
    coins = coins.filter(c => c.x + c.size > 0);

    for (const o of obstacles) {
      if (rectsCollide(player, o)) {
        gameState = "gameOver";
      }
    }

    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      if (rectsCollide(player, { x: c.x, y: c.y, width: c.size, height: c.size })) {
        score += c.value;
        coinsCollected++;
        coins.splice(i, 1);
      }
    }

    score += dt * 10 * speedMultiplier;
  }

  function rectsCollide(a, b) {
    return (
      a.x < b.x + b.width &&
      a.x + a.width > b.x &&
      a.y < b.y + b.height &&
      a.y + a.height > b.y
    );
  }

  function draw() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    ctx.fillStyle = "#333";
    ctx.fillRect(0, GROUND_Y, GAME_WIDTH, GROUND_HEIGHT);

    ctx.fillStyle = "#4caf50";
    ctx.fillRect(player.x, player.y, player.width, player.height);

    ctx.fillStyle = "#e53935";
    obstacles.forEach(o => {
      ctx.fillRect(o.x, o.y, o.width, o.height);
    });

    coins.forEach(c => {
      if (c.img.complete && c.img.naturalWidth > 0) {
        ctx.drawImage(c.img, c.x, c.y, c.size, c.size);
      } else {
        ctx.fillStyle = "#ffeb3b";
        ctx.fillRect(c.x, c.y, c.size, c.size);
      }
    });

    ctx.fillStyle = "#eee";
    ctx.font = "20px sans-serif";
    ctx.fillText("Score: " + Math.floor(score), 16, 32);
    ctx.fillText("Coins: " + coinsCollected, 16, 58);

    if (gameState === "gameOver") {
      ctx.font = "32px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", GAME_WIDTH / 2, GAME_HEIGHT / 2);
      ctx.font = "18px sans-serif";
      ctx.fillText("Press Space or Click to Restart", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);
    }
  }

  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = (ts - lastTime) / 1000;
    lastTime = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>
</body>
</html>
